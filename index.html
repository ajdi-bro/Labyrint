<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrint Utfordring</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #ui {
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            border: 4px solid #ecf0f1;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #34495e;
        }

        h1 { margin: 5px; }
        p { margin: 5px; color: #bdc3c7; }

        /* Konfetti-effekt */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            top: -10px;
            z-index: 100;
            animation: fall linear forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Labyrint: Nivå <span id="level">1</span></h1>
        <p>Bruk piltastene for å finne veien til den grønne firkanten!</p>
    </div>
    
    <canvas id="mazeCanvas"></canvas>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const levelDisplay = document.getElementById('level');

        let level = 1;
        let cols, rows;
        let cellSize;
        let grid = [];
        let stack = [];
        let player = { x: 0, y: 0 };
        let path = [{ x: 0, y: 0 }]; // Logg over hvor spilleren har vært

        function setup() {
            // Øk vanskelighetsgrad ved å legge til flere ruter
            cols = 10 + (level * 2);
            rows = 10 + (level * 2);
            
            // Tilpass cellestørrelse så den får plass på skjermen
            const maxSize = Math.min(window.innerWidth * 0.8, window.innerHeight * 0.7);
            cellSize = Math.floor(maxSize / cols);
            
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            grid = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid.push(new Cell(x, y));
                }
            }

            generateMaze();
            player = { x: 0, y: 0 };
            path = [{ x: 0, y: 0 }];
            draw();
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = [true, true, true, true]; // Topp, Høyre, Bunn, Venstre
                this.visited = false;
            }

            index(x, y) {
                if (x < 0 || y < 0 || x > cols - 1 || y > rows - 1) return -1;
                return x + y * cols;
            }

            checkNeighbors() {
                let neighbors = [];
                let top = grid[this.index(this.x, this.y - 1)];
                let right = grid[this.index(this.x + 1, this.y)];
                let bottom = grid[this.index(this.x, this.y + 1)];
                let left = grid[this.index(this.x - 1, this.y)];

                if (top && !top.visited) neighbors.push(top);
                if (right && !right.visited) neighbors.push(right);
                if (bottom && !bottom.visited) neighbors.push(bottom);
                if (left && !left.visited) neighbors.push(left);

                if (neighbors.length > 0) {
                    let r = Math.floor(Math.random() * neighbors.length);
                    return neighbors[r];
                } else {
                    return undefined;
                }
            }
        }

        function removeWalls(a, b) {
            let x = a.x - b.x;
            if (x === -1) { a.walls[1] = false; b.walls[3] = false; }
            else if (x === 1) { a.walls[3] = false; b.walls[1] = false; }
            let y = a.y - b.y;
            if (y === -1) { a.walls[2] = false; b.walls[0] = false; }
            else if (y === 1) { a.walls[0] = false; b.walls[2] = false; }
        }

        function generateMaze() {
            let current = grid[0];
            current.visited = true;
            stack = [current];

            while (stack.length > 0) {
                let next = current.checkNeighbors();
                if (next) {
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else {
                    current = stack.pop();
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Tegn labyrint-vegger
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            for (let cell of grid) {
                let x = cell.x * cellSize;
                let y = cell.y * cellSize;
                if (cell.walls[0]) ctx.strokeRect(x, y, cellSize, 0); // Topp
                if (cell.walls[1]) ctx.strokeRect(x + cellSize, y, 0, cellSize); // Høyre
                if (cell.walls[2]) ctx.strokeRect(x, y + cellSize, cellSize, 0); // Bunn
                if (cell.walls[3]) ctx.strokeRect(x, y, 0, cellSize); // Venstre
            }

            // Tegn mål (grønn firkant nederst til høyre)
            ctx.fillStyle = "#2ecc71";
            ctx.fillRect((cols - 1) * cellSize + 5, (rows - 1) * cellSize + 5, cellSize - 10, cellSize - 10);

            // Tegn stien spilleren har laget
            ctx.strokeStyle = "#e74c3c";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cellSize / 2, cellSize / 2);
            for (let p of path) {
                ctx.lineTo(p.x * cellSize + cellSize / 2, p.y * cellSize + cellSize / 2);
            }
            ctx.stroke();

            // Tegn spilleren (rød prikk)
            ctx.fillStyle = "#e74c3c";
            ctx.beginPath();
            ctx.arc(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
        }

        window.addEventListener('keydown', (e) => {
            let currentCell = grid[player.x + player.y * cols];
            let nextX = player.x;
            let nextY = player.y;
            let wallIndex;

            if (e.key === 'ArrowUp') { nextY--; wallIndex = 0; }
            else if (e.key === 'ArrowRight') { nextX++; wallIndex = 1; }
            else if (e.key === 'ArrowDown') { nextY++; wallIndex = 2; }
            else if (e.key === 'ArrowLeft') { nextX--; wallIndex = 3; }

            // Sjekk om trekket er lovlig (ingen vegg)
            if (wallIndex !== undefined && !currentCell.walls[wallIndex]) {
                
                // Sjekk om vi går tilbake i stien
                if (path.length > 1 && nextX === path[path.length - 2].x && nextY === path[path.length - 2].y) {
                    path.pop(); // Slett streken
                } else {
                    path.push({ x: nextX, y: nextY }); // Legg til ny strek
                }

                player.x = nextX;
                player.y = nextY;
                draw();

                // Sjekk seier
                if (player.x === cols - 1 && player.y === rows - 1) {
                    win();
                }
            }
        });

        function win() {
            createConfetti();
            level++;
            levelDisplay.innerText = level;
            setTimeout(() => {
                setup();
            }, 1000);
        }

        function createConfetti() {
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                confetti.style.animationDuration = (Math.random() * 2 + 1) + 's';
                confetti.style.opacity = Math.random();
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 3000);
            }
        }

        setup();
    </script>
</body>
</html>
