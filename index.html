<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Pro Maze</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Arial Black', sans-serif;
            overflow: hidden;
        }

        #ui { margin-bottom: 10px; text-align: center; color: #000; }

        canvas {
            background-color: #fff;
            border: 8px solid #000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            image-rendering: crisp-edges;
        }

        .confetti {
            position: absolute;
            width: 10px; height: 10px;
            z-index: 1000;
            animation: fall linear forwards;
        }

        @keyframes fall { to { transform: translateY(110vh) rotate(360deg); } }
    </style>
</head>
<body>

    <div id="ui">
        <h2 style="margin:0">NIVÅ <span id="level">1</span></h2>
        <p style="margin:0; font-size: 0.8em;">Finn veien gjennom kaoset</p>
    </div>
    
    <canvas id="mazeCanvas"></canvas>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const levelDisplay = document.getElementById('level');

        let level = 1;
        let cols, rows, cellSize;
        let grid = [];
        let player = { x: 0, y: 0 };
        let path = [{ x: 0, y: 0 }];

        function setup() {
            // Starter ekstremt tett (50x50 ruter) for å ligne bildene dine
            cols = 45 + (level * 5);
            rows = 45 + (level * 5);
            
            const maxSize = Math.min(window.innerWidth * 0.95, window.innerHeight * 0.8);
            cellSize = maxSize / cols;
            
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            grid = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid.push(new Cell(x, y));
                }
            }

            generateDenseMaze();
            player = { x: 0, y: 0 };
            path = [{ x: 0, y: 0 }];
            draw();
        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = [true, true, true, true]; // Topp, Høyre, Bunn, Venstre
                this.visited = false;
            }
            index(x, y) {
                if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
                return x + y * cols;
            }
        }

        function generateDenseMaze() {
            let stack = [];
            let current = grid[0];
            current.visited = true;
            stack.push(current);

            while (stack.length > 0) {
                let neighbors = getUnvisitedNeighbors(current);
                if (neighbors.length > 0) {
                    // Velger en tilfeldig nabo for å skape uforutsigbare avvik
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else {
                    current = stack.pop();
                }
            }
        }

        function getUnvisitedNeighbors(cell) {
            let ns = [];
            let {x, y} = cell;
            let check = [[x, y-1, 0], [x+1, y, 1], [x, y+1, 2], [x-1, y, 3]];
            for (let [nx, ny, wall] of check) {
                let neighbor = grid[cell.index(nx, ny)];
                if (neighbor && !neighbor.visited) ns.push(neighbor);
            }
            return ns;
        }

        function removeWalls(a, b) {
            let x = a.x - b.x;
            if (x === -1) { a.walls[1] = false; b.walls[3] = false; }
            else if (x === 1) { a.walls[3] = false; b.walls[1] = false; }
            let y = a.y - b.y;
            if (y === -1) { a.walls[2] = false; b.walls[0] = false; }
            else if (y === 1) { a.walls[0] = false; b.walls[2] = false; }
        }

        function draw() {
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Tegn tykke, svarte vegger slik som på tegningene
            ctx.strokeStyle = "#000";
            ctx.lineWidth = Math.max(1, cellSize / 4);
            ctx.lineCap = "square";
            
            for (let cell of grid) {
                let x = cell.x * cellSize;
                let y = cell.y * cellSize;
                if (cell.walls[0]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + cellSize, y); ctx.stroke(); }
                if (cell.walls[1]) { ctx.beginPath(); ctx.moveTo(x + cellSize, y); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); }
                if (cell.walls[2]) { ctx.beginPath(); ctx.moveTo(x, y + cellSize); ctx.lineTo(x + cellSize, y + cellSize); ctx.stroke(); }
                if (cell.walls[3]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + cellSize); ctx.stroke(); }
            }

            // Sluttpunkt (Mål) - Markert med en liten grønn firkant
            ctx.fillStyle = "#2ecc71";
            ctx.fillRect((cols-1)*cellSize + 2, (rows-1)*cellSize + 2, cellSize-4, cellSize-4);

            // Spillerens rød strek (tydelig og glødende)
            if (path.length > 1) {
                ctx.strokeStyle = "#ff0000";
                ctx.lineWidth = Math.max(2, cellSize / 2);
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(path[0].x * cellSize + cellSize/2, path[0].y * cellSize + cellSize/2);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x * cellSize + cellSize/2, path[i].y * cellSize + cellSize/2);
                }
                ctx.stroke();
            }

            // Spilleren (Rød prikk)
            ctx.fillStyle = "#ff0000";
            ctx.beginPath();
            ctx.arc(player.x * cellSize + cellSize/2, player.y * cellSize + cellSize/2, cellSize/2.5, 0, Math.PI*2);
            ctx.fill();
        }

        window.addEventListener('keydown', (e) => {
            if (!e.key.startsWith('Arrow')) return;
            e.preventDefault();
            let cur = grid[player.x + player.y * cols];
            let nx = player.x, ny = player.y, wi;

            if (e.key === 'ArrowUp') { ny--; wi = 0; }
            else if (e.key === 'ArrowRight') { nx++; wi = 1; }
            else if (e.key === 'ArrowDown') { ny++; wi = 2; }
            else if (e.key === 'ArrowLeft') { nx--; wi = 3; }

            if (wi !== undefined && !cur.walls[wi]) {
                if (path.length > 1 && nx === path[path.length - 2].x && ny === path[path.length - 2].y) {
                    path.pop();
                } else {
                    path.push({ x: nx, y: ny });
                }
                player.x = nx; player.y = ny;
                draw();
                if (player.x === cols - 1 && player.y === rows - 1) win();
            }
        });

        function win() {
            for (let i = 0; i < 150; i++) {
                const c = document.createElement('div');
                c.className = 'confetti';
                c.style.left = Math.random() * 100 + 'vw';
                c.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                c.style.animationDuration = (Math.random() * 2 + 1) + 's';
                document.body.appendChild(c);
                setTimeout(() => c.remove(), 2500);
            }
            level++;
            levelDisplay.innerText = level;
            setTimeout(setup, 1000);
        }

        setup();
    </script>
</body>
</html>
